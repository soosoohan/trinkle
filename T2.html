<!DOCTYPE html>

<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Trinkle vs AI</title>
  <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

* {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }


html {
    background: #0b0c1a !important;
}

body,
.game-container {
    background: #2e8b8b ;
    font-family: 'Pretendard', sans-serif;
    height: 100vh;
    overflow: hidden;
    min-height: 100vh;
}

.game-container {
    width: 100vw;
    height: 100vh;
    position: relative;
    background: #2e8b8b ;
    
}

.header {
    text-align: center;
    padding: 15px;
    color: white;
    position: relative;
}

.game-title {
    font-size: 2rem;
    font-weight: bold;
    width: 30%;
    margin: 0 auto;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

.buttons {
    position: absolute;
    top: 20px;
    left: 20px;
    display: flex;
    gap: 10px;
}

.game-button {
    padding: 10px 20px;
    background: rgba(255,255,255,0.9);
    border: none;
    border-radius: 8px;
    font-family: 'Pretendard', sans-serif;
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    color: #2e8b8b;
}

.game-button:hover {
    background: rgba(255,255,255,1);
    transform: scale(1.05);
}

.game-area {
    position: absolute;
    top: 80px;
    left: 0;
    right: 0;
    bottom: 0;
    background: #2e8b8b ;
    }
.point {
    position: absolute;
    width: 50px;
    height: 50px;
    cursor: pointer;
    z-index: 100;
    pointer-events: auto;
    display: flex;
    align-items: center;
    justify-content: center;
}

.point::before {
    content: '';
    width: 16px;
    height: 16px;
    background: #F7f783;
    border-radius: 50%;
    transition: all 0.2s ease;
}

.point:hover::before {
    transform: scale(1.2);
    background: #Fcefa4;
    }

.point.selected::before {
    background: #F7f883;
    transform: scale(1.3);
    }

.line {
    position: absolute;
    height: 3px;
    transform-origin: left center;
    z-index: 5;
}

.triangle {
    position: absolute;
    font-size: 24px;
    font-weight: bold;
    z-index: 40;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
}

.scoreboard {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: #2e8b8b
    padding: 15px;
    min-width: 180px;
    font-family: 'Pretendard', sans-serif;
    color: #fffde7;
    z-index: 50;
    pointer-events: auto;
}

.player-score {
    margin: 8px 0;
    font-size: 25px;
    font-weight: bold;
    }

.player1 { color: white; }
.player2 { color: pink; }

.turn-indicator {
    font-size: 25px;
    animation: pulse 1s infinite;
}

.current-turn {
    text-align: center;
    margin-top: 10px;
    font-size: 25px;
    font-weight: bold;
    padding: 5px;
    border-radius: 5px;
    background: #2e8b8b
    font-family: 'Pretendard', sans-serif;
    color: #fff;
}

.ai-thinking {
    background: rgba(255, 107, 107, 0.2) !important;
    animation: aiThinking 1.5s infinite;
}

/* ë°˜ì‘í˜• ë””ìì¸ */
@media (max-width: 768px) {
    .game-title {
        font-size: 1.5rem;
        width: 50%;
    }
    
    .buttons {
        position: static;
        margin-bottom: 10px;
        justify-content: center;
    }
    
    .header {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px;
    }
    
    .scoreboard {
        bottom: 10px;
        right: 10px;
        min-width: 150px;
        padding: 10px;
        font-size: 14px;
    }
    
    .point {
        width: 60px;
        height: 60px;
    }
}
@media (max-height: 800px) {
    .blackboard {
        border: none;  /* í…Œë‘ë¦¬ ì œê±° */
        width: 100vw;
        height: 100vh;
        border-radius: 0;
    }
}


</style>

</head>
<body>
  <div class="game-container">
    <div class="header">
      <div class="buttons">
        <button class="game-button" onclick="restartGame()">Restart</button>
        <button class="game-button" onclick="goToIndex()">Index</button>
      </div>
      <h1 class="game-title">âœ¨ TRINKLE vs TRINKY âœ¨</h1>
    </div>

<div class="game-area" id="gameArea">
  <div class="scoreboard">
    <div class="player-score player1">
      <span id="player1Name">You</span>: <span id="score1">0</span> <span class="turn-indicator" id="turn1">â­</span>
    </div>
    <div class="player-score player2">
      <span id="player2Name">Trinky</span>: <span id="score2">0</span> <span class="turn-indicator" id="turn2" style="display:none;">ğŸ¤–</span>
    </div>
    <div class="current-turn" id="currentTurn">Your Turn</div>
  </div>
</div>

  </div>

<script>
    console.log("ìŠ¤í¬ë¦½íŠ¸ ì‹œì‘");
    
    const gameArea = document.getElementById('gameArea');
    const scoreBoard = document.querySelector('.scoreboard');
    let points = [];
    let lines = [];
    let triangles = [];
    let currentPlayer = 1;
    let selectedPoint = null;
    let scores = { player1: 0, player2: 0 };
    let gameMode = 'ai';
    let isAiThinking = false;

    function createPoints() {
        console.log("Creating points");

        const areaRect = gameArea.getBoundingClientRect();
        const minDistance = Math.min(areaRect.width, areaRect.height) * 0.18;
        const margin = 40;
        const pointCount = 16; // ì ì˜ ê°œìˆ˜

        // ê¸ˆì§€ êµ¬ì—­ ì •ì˜
        const forbiddenZones = [
            { x: 0, y: 0, width: 250, height: 100 },
            { x: areaRect.width - 250, y: areaRect.height - 180, width: 250, height: 180 }
        ];

        function isInForbiddenZone(x, y) {
            for (let zone of forbiddenZones) {
                if (x >= zone.x && x <= zone.x + zone.width && 
                    y >= zone.y && y <= zone.y + zone.height) {
                    return true;
                }
            }
            return false;
        }

        for (let i = 0; i < pointCount; i++) {
            let validPosition = false;
            let attempts = 0;
            let x, y;

            while (!validPosition && attempts < 100) {
                x = margin + Math.random() * (areaRect.width - 2 * margin);
                y = margin + Math.random() * (areaRect.height - 2 * margin);

                validPosition = true;
                
                if (isInForbiddenZone(x, y)) {
                    validPosition = false;
                    attempts++;
                    continue;
                }
                
                for (let existingPoint of points) {
                    const distance = Math.sqrt(Math.pow(x - existingPoint.x, 2) + Math.pow(y - existingPoint.y, 2));
                    if (distance < minDistance) {
                        validPosition = false;
                        break;
                    }
                }
                attempts++;
            }

            if (validPosition) {
                const point = document.createElement('div');
                point.className = 'point';
                point.style.left = (x - 25) + 'px';
                point.style.top = (y - 25) + 'px';
                
                point.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!isAiThinking && currentPlayer === 1) {
                        selectPoint(i, x, y);
                    }
                });
                
                gameArea.appendChild(point);
                points.push({ x, y, element: point, id: i });
                console.log("Point created:", i, x, y);
            }
        }
        console.log("Total points:", points.length);
    }

    function selectPoint(pointId, x, y) {
        console.log("Point selected:", pointId);
        
        if (selectedPoint === null) {
            selectedPoint = { id: pointId, x, y };
            points[pointId].element.classList.add('selected');
        } else if (selectedPoint.id === pointId) {
            points[pointId].element.classList.remove('selected');
            selectedPoint = null;
        } else {
            drawLine(selectedPoint, { id: pointId, x, y });
            points[selectedPoint.id].element.classList.remove('selected');
            selectedPoint = null;
        }
    }

    function drawLine(point1, point2) {
        console.log("Drawing line:", point1.id, "->", point2.id);

        const existingLine = lines.find(line =>
            (line.point1 === point1.id && line.point2 === point2.id) ||
            (line.point1 === point2.id && line.point2 === point1.id)
        );

        if (existingLine) {
            console.log("Line already exists");
            return;
        }

        if (lineIntersectsExistingLines(point1, point2)) {
            console.log("Line intersects existing line or passes too close to a point");
            showWarningMessage("ì„ ë¶„ì´ ë‹¤ë¥¸ ì„ ë¶„ê³¼ êµì°¨í•˜ê±°ë‚˜ ì ì„ ì§€ë‚˜ê°ˆ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!");
            return;
        }

        const line = document.createElement('div');
        line.className = 'line';

        const dx = point2.x - point1.x;
        const dy = point2.y - point1.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;

        line.style.width = length + 'px';
        line.style.left = point1.x + 'px';
        line.style.top = (point1.y - 1.5) + 'px';
        line.style.transform = `rotate(${angle}deg)`;
        line.style.background = currentPlayer === 1 ? 'white' : 'pink';

        gameArea.appendChild(line);
        lines.push({
            point1: point1.id,
            point2: point2.id,
            player: currentPlayer,
            element: line
        });

        // ìƒˆë¡œ ê·¸ì€ ì„ ë¶„ì´ ì§ì ‘ ì™„ì„±í•˜ëŠ” ì‚¼ê°í˜•ë§Œ ì²´í¬í•˜ì—¬ ì ìˆ˜ ë¶€ì—¬
        const newTriangles = checkForDirectTrianglesOnly(point1.id, point2.id);
        if (newTriangles.length > 0) {
            console.log(`ğŸ”º ì‚¼ê°í˜• ${newTriangles.length}ê°œ ì™„ì„±! í”Œë ˆì´ì–´ ${currentPlayer} ê³„ì† ì§„í–‰`);
            newTriangles.forEach(triangle => createTriangle(triangle));
            scores[`player${currentPlayer}`] += newTriangles.length;
            updateScoreboard();
            // ì‚¼ê°í˜•ì„ ì™„ì„±í–ˆìœ¼ë¯€ë¡œ ê°™ì€ í”Œë ˆì´ì–´ê°€ ê³„ì† ì§„í–‰
            updateTurnDisplay();
        } else {
            console.log(`â¡ï¸ ì‚¼ê°í˜• ì—†ìŒ. í„´ êµì²´: ${currentPlayer} -> ${currentPlayer === 1 ? 2 : 1}`);
            // ì‚¼ê°í˜•ì„ ì™„ì„±í•˜ì§€ ëª»í–ˆìœ¼ë¯€ë¡œ í„´ êµì²´
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateTurnDisplay();
        }

        // AI í„´ì¸ ê²½ìš° ìë™ìœ¼ë¡œ ìˆ˜í–‰
        if (currentPlayer === 2 && !isAiThinking) {
            console.log("ğŸ¤– AI í„´ ê°ì§€ - makeAiMove í˜¸ì¶œ");
            // ê²Œì„ì´ ëë‚¬ëŠ”ì§€ ë¨¼ì € í™•ì¸
            if (isGameOver()) {
                console.log("ğŸ ê²Œì„ ì¢…ë£Œ!");
                showGameEndMessage();
            } else {
                setTimeout(makeAiMove, 1000);
            }
        } else if (currentPlayer === 1 && isGameOver()) {
            console.log("ğŸ ê²Œì„ ì¢…ë£Œ!");
            showGameEndMessage();
        }
    }

    // ì—„ê²©í•œ ë£°: ë¹ˆ ê³µê°„ì— ìƒˆë¡œ ì™„ì„±ë˜ëŠ” ì‚¼ê°í˜•ë§Œ ì ìˆ˜ ë¶€ì—¬
    function checkForDirectTrianglesOnly(newPoint1, newPoint2) {
        const completedTriangles = [];
        
        console.log(`ğŸ” ì—„ê²©í•œ ì‚¼ê°í˜• ì²´í¬: ìƒˆë¡œ ê·¸ì€ ì„  ${newPoint1}-${newPoint2}`);
        
        for (let point of points) {
            if (point.id === newPoint1 || point.id === newPoint2) continue;
            
            // ì²« ë²ˆì§¸ ì„ : newPoint1 â†” point.id
            const hasLine1 = lines.some(line => 
                (line.point1 === newPoint1 && line.point2 === point.id) ||
                (line.point1 === point.id && line.point2 === newPoint1)
            );
            
            // ë‘ ë²ˆì§¸ ì„ : newPoint2 â†” point.id  
            const hasLine2 = lines.some(line => 
                (line.point1 === newPoint2 && line.point2 === point.id) ||
                (line.point1 === point.id && line.point2 === newPoint2)
            );

            if (hasLine1 && hasLine2) {
                const triangle = [newPoint1, newPoint2, point.id].sort((a, b) => a - b);
                
                // ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì‚¼ê°í˜•ì¸ì§€ í™•ì¸
                const triangleExists = triangles.some(existingTriangle => {
                    const existingPoints = existingTriangle.points.slice().sort((a, b) => a - b);
                    return JSON.stringify(triangle) === JSON.stringify(existingPoints);
                });
                
                if (triangleExists) {
                    console.log(`âŒ ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì‚¼ê°í˜•: ${triangle.join('-')}`);
                    continue;
                }
                
                // ğŸš« ì—„ê²©í•œ ë£°: ì‚¼ê°í˜• ë‚´ë¶€ì— ë‹¤ë¥¸ ì ì´ë‚˜ ì‚¼ê°í˜•ì´ ìˆìœ¼ë©´ ì ìˆ˜ ì—†ìŒ
                const hasInteriorElements = triangleHasInteriorElements(triangle);
                if (hasInteriorElements) {
                    console.log(`âŒ ì‚¼ê°í˜• ë‚´ë¶€ì— ë‹¤ë¥¸ ìš”ì†Œê°€ ìˆìŒ: ${triangle.join('-')}`);
                    continue;
                }
                
                // ìƒˆë¡œ ê·¸ì€ ì„ ë¶„ì´ ì´ ì‚¼ê°í˜•ì„ ì§ì ‘ì ìœ¼ë¡œ ì™„ì„±í•˜ëŠ”ì§€ í™•ì¸
                const isDirectTriangle = isTriangleDirectlyFormedByNewLine(triangle, newPoint1, newPoint2);
                
                if (isDirectTriangle) {
                    console.log(`âœ… ë¹ˆ ê³µê°„ì— ìƒˆë¡œ ì™„ì„±ëœ ì‚¼ê°í˜•: ${triangle.join('-')}`);
                    completedTriangles.push(triangle);
                } else {
                    console.log(`âŒ ê°„ì ‘ì  ì‚¼ê°í˜•: ${triangle.join('-')}`);
                }
            }
        }
        
        console.log(`ğŸ” ìµœì¢… ì—„ê²©í•œ ì‚¼ê°í˜• ì²´í¬ ê²°ê³¼: ${completedTriangles.length}ê°œ ë°œê²¬`);
        return completedTriangles;
    }

    // ì‚¼ê°í˜• ë‚´ë¶€ì— ë‹¤ë¥¸ ì ì´ë‚˜ ê¸°ì¡´ ì‚¼ê°í˜•ì´ ìˆëŠ”ì§€ í™•ì¸
    function triangleHasInteriorElements(trianglePoints) {
        const [p1, p2, p3] = trianglePoints;
        const point1 = points[p1];
        const point2 = points[p2];
        const point3 = points[p3];
        
        // 1. ì‚¼ê°í˜• ë‚´ë¶€ì— ë‹¤ë¥¸ ì ì´ ìˆëŠ”ì§€ í™•ì¸
        for (let point of points) {
            if (trianglePoints.includes(point.id)) continue;
            
            if (isPointInsideTriangle(point.x, point.y, point1.x, point1.y, point2.x, point2.y, point3.x, point3.y)) {
                console.log(`ğŸ” ì‚¼ê°í˜• ${trianglePoints.join('-')} ë‚´ë¶€ì— ì  ${point.id} ë°œê²¬`);
                return true;
            }
        }
        
        // 2. ì‚¼ê°í˜• ë‚´ë¶€ì— ê¸°ì¡´ ì‚¼ê°í˜•ì´ ìˆëŠ”ì§€ í™•ì¸
        for (let existingTriangle of triangles) {
            const [ep1, ep2, ep3] = existingTriangle.points;
            const epoint1 = points[ep1];
            const epoint2 = points[ep2];
            const epoint3 = points[ep3];
            
            // ê¸°ì¡´ ì‚¼ê°í˜•ì˜ ì¤‘ì‹¬ì ì´ ìƒˆ ì‚¼ê°í˜• ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸
            const centerX = (epoint1.x + epoint2.x + epoint3.x) / 3;
            const centerY = (epoint1.y + epoint2.y + epoint3.y) / 3;
            
            if (isPointInsideTriangle(centerX, centerY, point1.x, point1.y, point2.x, point2.y, point3.x, point3.y)) {
                console.log(`ğŸ” ì‚¼ê°í˜• ${trianglePoints.join('-')} ë‚´ë¶€ì— ê¸°ì¡´ ì‚¼ê°í˜• ${existingTriangle.points.join('-')} ë°œê²¬`);
                return true;
            }
        }
        
        return false;
    }

    // ì ì´ ì‚¼ê°í˜• ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸ (Barycentric ì¢Œí‘œ ì‚¬ìš©)
    function isPointInsideTriangle(px, py, x1, y1, x2, y2, x3, y3) {
        const denominator = ((y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3));
        
        if (Math.abs(denominator) < 1e-10) return false; // ì‚¼ê°í˜•ì´ ì•„ë‹˜
        
        const a = ((y2 - y3) * (px - x3) + (x3 - x2) * (py - y3)) / denominator;
        const b = ((y3 - y1) * (px - x3) + (x1 - x3) * (py - y3)) / denominator;
        const c = 1 - a - b;
        
        // ë‚´ë¶€ì— ìˆìœ¼ë ¤ë©´ ëª¨ë“  barycentric ì¢Œí‘œê°€ 0ë³´ë‹¤ ì»¤ì•¼ í•¨ (ê²½ê³„ ì œì™¸)
        return a > 0.01 && b > 0.01 && c > 0.01;
    }

    // ìƒˆë¡œ ê·¸ì€ ì„ ë¶„ì´ ì‚¼ê°í˜•ì„ ì§ì ‘ì ìœ¼ë¡œ ì™„ì„±í•˜ëŠ”ì§€ í™•ì¸
    function isTriangleDirectlyFormedByNewLine(triangle, newPoint1, newPoint2) {
        // ì‚¼ê°í˜•ì˜ ì„¸ ë³€ ì¤‘ ìƒˆë¡œ ê·¸ì€ ì„ ë¶„ì´ í•˜ë‚˜ì—¬ì•¼ í•¨
        const [p1, p2, p3] = triangle;
        
        // ì‚¼ê°í˜•ì˜ ì„¸ ë³€ì„ í™•ì¸
        const side1 = [p1, p2].sort((a, b) => a - b);
        const side2 = [p1, p3].sort((a, b) => a - b);
        const side3 = [p2, p3].sort((a, b) => a - b);
        
        const newLine = [newPoint1, newPoint2].sort((a, b) => a - b);
        
        // ìƒˆë¡œ ê·¸ì€ ì„ ë¶„ì´ ì‚¼ê°í˜•ì˜ í•œ ë³€ê³¼ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
        const isNewLineSide1 = JSON.stringify(side1) === JSON.stringify(newLine);
        const isNewLineSide2 = JSON.stringify(side2) === JSON.stringify(newLine);
        const isNewLineSide3 = JSON.stringify(side3) === JSON.stringify(newLine);
        
        const newLineMatchesOneSide = isNewLineSide1 || isNewLineSide2 || isNewLineSide3;
        
        if (newLineMatchesOneSide) {
            // ë‚˜ë¨¸ì§€ ë‘ ë³€ì´ ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
            let otherSidesExist = 0;
            
            if (!isNewLineSide1) {
                const side1Exists = lines.some(line => 
                    (line.point1 === side1[0] && line.point2 === side1[1]) ||
                    (line.point1 === side1[1] && line.point2 === side1[0])
                );
                if (side1Exists) otherSidesExist++;
            }
            
            if (!isNewLineSide2) {
                const side2Exists = lines.some(line => 
                    (line.point1 === side2[0] && line.point2 === side2[1]) ||
                    (line.point1 === side2[1] && line.point2 === side2[0])
                );
                if (side2Exists) otherSidesExist++;
            }
            
            if (!isNewLineSide3) {
                const side3Exists = lines.some(line => 
                    (line.point1 === side3[0] && line.point2 === side3[1]) ||
                    (line.point1 === side3[1] && line.point2 === side3[0])
                );
                if (side3Exists) otherSidesExist++;
            }
            
            // ì •í™•íˆ 2ê°œì˜ ë‹¤ë¥¸ ë³€ì´ ì´ë¯¸ ì¡´ì¬í•´ì•¼ ì§ì ‘ì ì¸ ì‚¼ê°í˜• ì™„ì„±
            return otherSidesExist === 2;
        }
        
        return false;
    }

    function makeAiMove() {
        if (isAiThinking || currentPlayer !== 2) return;

        isAiThinking = true;
        updateTurnDisplay();

        console.log("ğŸ¤– AIê°€ ìƒê° ì¤‘...");

        const thinkingTime = 800 + Math.random() * 700;

        setTimeout(() => {
            const bestMove = findBestAiMoveAdvanced();
            
            if (bestMove) {
                console.log("ğŸ¯ AIê°€ ì„ íƒí•œ ìˆ˜:", bestMove);
                
                const point1 = points[bestMove.point1];
                const point2 = points[bestMove.point2];
                
                point1.element.classList.add('selected');
                point2.element.classList.add('selected');
                
                setTimeout(() => {
                    point1.element.classList.remove('selected');
                    point2.element.classList.remove('selected');
                    
                    drawLine(
                        { id: bestMove.point1, x: point1.x, y: point1.y },
                        { id: bestMove.point2, x: point2.x, y: point2.y }
                    );
                    
                    isAiThinking = false;
                    updateTurnDisplay();
                    
                    // ì‚¼ê°í˜• ì™„ì„± í›„ AIê°€ ê³„ì† í„´ì„ ê°€ì§€ëŠ”ì§€ í™•ì¸
                    console.log("ğŸ”„ AI ìˆ˜ ì™„ë£Œ í›„ - currentPlayer:", currentPlayer, "isAiThinking:", isAiThinking);
                    
                    // AIê°€ ê³„ì† í„´ì„ ê°€ì§„ë‹¤ë©´ ë‹¤ì‹œ ìˆ˜í–‰ (ë‹¨, ê²Œì„ì´ ëë‚˜ì§€ ì•Šì•˜ë‹¤ë©´)
                    if (currentPlayer === 2 && !isAiThinking && !isGameOver()) {
                        console.log("ğŸ¯ AI ì—°ì† í„´ ì‹œì‘!");
                        setTimeout(makeAiMove, 800);
                    } else if (isGameOver()) {
                        console.log("ğŸ AI ìˆ˜ í›„ ê²Œì„ ì¢…ë£Œ!");
                        showGameEndMessage();
                    }
                }, 500);
            } else {
                isAiThinking = false;
                updateTurnDisplay();
                console.log("âŒ AIì—ê²Œ ìœ íš¨í•œ ìˆ˜ê°€ ì—†ìŒ - ê²Œì„ ì¢…ë£Œ ì²´í¬");
                if (isGameOver()) {
                    showGameEndMessage();
                }
            }
        }, thinkingTime);
    }

    // ë˜‘ë˜‘í•œ AI ì „ëµ í•¨ìˆ˜ (ê²Œì„ ë‹¨ê³„ë³„ ì „ëµ)
    function findBestAiMoveAdvanced() {
        const possibleMoves = getAllValidMoves();

        if (possibleMoves.length === 0) {
            console.log("âš ï¸ ê°€ëŠ¥í•œ ìˆ˜ê°€ ì—†ìŒ");
            return null;
        }

        console.log(`ğŸ” ì´ ${possibleMoves.length}ê°œì˜ ê°€ëŠ¥í•œ ìˆ˜ ë¶„ì„ ì¤‘...`);

        // ê²Œì„ ì§„í–‰ ë‹¨ê³„ íŒŒì•…
        const totalLines = lines.length;
        const gamePhase = getGamePhase(totalLines);
        console.log(`ğŸ® ê²Œì„ ë‹¨ê³„: ${gamePhase} (ì´ ${totalLines}ê°œ ì„ ë¶„)`);

        // 1ë‹¨ê³„: ì‚¼ê°í˜• ì™„ì„± ìš°ì„  (í•­ìƒ ìµœìš°ì„ )
        const triangleCompletingMoves = findTriangleCompletingMoves(possibleMoves);
        if (triangleCompletingMoves.length > 0) {
            console.log(`ğŸ¯ ì‚¼ê°í˜• ì™„ì„± ê°€ëŠ¥í•œ ìˆ˜: ${triangleCompletingMoves.length}ê°œ`);
            console.log("ìµœìš°ì„ ìœ¼ë¡œ ì‚¼ê°í˜• ì™„ì„± ìˆ˜í–‰!");
            return selectBestFromMoves(triangleCompletingMoves, "triangle");
        }

        console.log("âŒ ì¦‰ì‹œ ì™„ì„± ê°€ëŠ¥í•œ ì‚¼ê°í˜• ì—†ìŒ");

        // ê²Œì„ ë‹¨ê³„ë³„ ì „ëµ
        if (gamePhase === 'early') {
            console.log("ğŸŒ± ì´ˆë°˜ ì „ëµ: ìƒˆë¡œìš´ ì˜ì—­ ê°œì²™");
            return findEarlyGameMove(possibleMoves);
        } else if (gamePhase === 'mid') {
            console.log("âš”ï¸ ì¤‘ë°˜ ì „ëµ: ê· í˜•ì¡íŒ í™•ì¥");
            return findMidGameMove(possibleMoves);
        } else {
            console.log("ğŸ”¥ í›„ë°˜ ì „ëµ: ì ê·¹ì  ê³µê²©");
            return findLateGameMove(possibleMoves);
        }
    }

    // ê²Œì„ ì§„í–‰ ë‹¨ê³„ íŒë‹¨
    function getGamePhase(totalLines) {
        const maxPossibleLines = (points.length * (points.length - 1)) / 2; // ì™„ì „ê·¸ë˜í”„
        const progress = totalLines / maxPossibleLines;
        
        if (progress < 0.3) return 'early';    // 30% ë¯¸ë§Œ
        if (progress < 0.7) return 'mid';      // 30-70%
        return 'late';                          // 70% ì´ìƒ
    }

    // ì´ˆë°˜ ê²Œì„ ì „ëµ: ìƒˆë¡œìš´ ì˜ì—­ ê°œì²™
    function findEarlyGameMove(possibleMoves) {
        console.log("ğŸŒ± ì´ˆë°˜: ë¹„ì–´ìˆëŠ” ì ë“¤ ìš°ì„  ì—°ê²°");
        
        // 1. ì™„ì „íˆ ê³ ë¦½ëœ ì ë“¤ë¼ë¦¬ ì—°ê²° (ìµœìš°ì„ )
        const isolatedMoves = findIsolatedPointMoves(possibleMoves);
        if (isolatedMoves.length > 0) {
            console.log(`âœ¨ ê³ ë¦½ëœ ì ë“¤ ì—°ê²°: ${isolatedMoves.length}ê°œ`);
            return selectBestFromMoves(isolatedMoves, "strategic");
        }

        // 2. í•œìª½ë§Œ ì—°ê²°ëœ ì ê³¼ ê³ ë¦½ëœ ì  ì—°ê²°
        const extensionMoves = findExtensionMoves(possibleMoves);
        if (extensionMoves.length > 0) {
            console.log(`ğŸ”— í™•ì¥ ê°€ëŠ¥: ${extensionMoves.length}ê°œ`);
            return selectBestFromMoves(extensionMoves, "strategic");
        }

        // 3. ê·¸ ì™¸ëŠ” ì „ëµì  ì ìˆ˜ë¡œ íŒë‹¨
        console.log(`âš¡ ê¸°íƒ€ ì „ëµì  ìˆ˜: ${possibleMoves.length}ê°œ`);
        return selectBestFromMoves(possibleMoves, "strategic");
    }

    // ì¤‘ë°˜ ê²Œì„ ì „ëµ: ê· í˜•ì¡íŒ í™•ì¥
    function findMidGameMove(possibleMoves) {
        console.log("âš”ï¸ ì¤‘ë°˜: ì‚¼ê°í˜• ê¸°íšŒì™€ ì˜ì—­ í™•ì¥ ê· í˜•");
        
        // 1. ì‚¼ê°í˜• ì™„ì„±ì— ê°€ê¹Œìš´ ìˆ˜ë“¤ (í•˜ì§€ë§Œ ì´ˆë°˜ë³´ë‹¤ ëœ ìš°ì„ ì‹œ)
        const nearTriangleMoves = findNearTriangleMoves(possibleMoves);
        
        // 2. ìƒˆë¡œìš´ ì˜ì—­ í™•ì¥
        const isolatedMoves = findIsolatedPointMoves(possibleMoves);
        const extensionMoves = findExtensionMoves(possibleMoves);

        // ê· í˜•ì¡íŒ ì„ íƒ
        const allCandidates = [
            ...nearTriangleMoves.slice(0, 2), // ìƒìœ„ 2ê°œë§Œ
            ...isolatedMoves,
            ...extensionMoves
        ];

        if (allCandidates.length > 0) {
            console.log(`ğŸ¯ ê· í˜•ì¡íŒ í›„ë³´ë“¤: ${allCandidates.length}ê°œ`);
            return selectBestFromMoves(allCandidates, "strategic");
        }

        return selectBestFromMoves(possibleMoves, "strategic");
    }

    // í›„ë°˜ ê²Œì„ ì „ëµ: ì ê·¹ì  ê³µê²©
    function findLateGameMove(possibleMoves) {
        console.log("ğŸ”¥ í›„ë°˜: ì ê·¹ì ìœ¼ë¡œ ì‚¼ê°í˜• ê¸°íšŒ ì¶”êµ¬");
        
        // 1. ì‚¼ê°í˜• ì™„ì„±ì— ê°€ê¹Œìš´ ìˆ˜ë“¤ ìš°ì„ 
        const nearTriangleMoves = findNearTriangleMoves(possibleMoves);
        if (nearTriangleMoves.length > 0) {
            console.log(`ğŸ”¶ ì‚¼ê°í˜• ì™„ì„±ì— ê°€ê¹Œìš´ ìˆ˜: ${nearTriangleMoves.length}ê°œ`);
            return selectBestFromMoves(nearTriangleMoves, "strategic");
        }

        // 2. ê¸°íƒ€ ëª¨ë“  ìˆ˜
        return selectBestFromMoves(possibleMoves, "strategic");
    }

    // ì‚¼ê°í˜• ì™„ì„±ì— ê°€ê¹Œìš´ ìˆ˜ë“¤ ì°¾ê¸° (2ê°œ ë³€ ì¤‘ 1ê°œ ë³€ë§Œ ìˆëŠ” ê²½ìš°)
    function findNearTriangleMoves(possibleMoves) {
        const nearMoves = [];

        for (let move of possibleMoves) {
            let potentialTriangles = 0;
            
            // ì´ ìˆ˜ë¥¼ ë‘ì—ˆì„ ë•Œ ë¯¸ë˜ì— ì‚¼ê°í˜•ì„ ì™„ì„±í•  ìˆ˜ ìˆëŠ” ê¸°íšŒê°€ ëª‡ ê°œë‚˜ ìƒê¸°ëŠ”ì§€ ê³„ì‚°
            for (let point of points) {
                if (point.id === move.point1 || point.id === move.point2) continue;
                
                // move.point1ê³¼ point.idë¥¼ ì—°ê²°í•˜ëŠ” ì„ ì´ ìˆëŠ”ì§€
                const hasLine1 = lines.some(line => 
                    (line.point1 === move.point1 && line.point2 === point.id) ||
                    (line.point1 === point.id && line.point2 === move.point1)
                );
                
                // move.point2ì™€ point.idë¥¼ ì—°ê²°í•˜ëŠ” ì„ ì´ ìˆëŠ”ì§€
                const hasLine2 = lines.some(line => 
                    (line.point1 === move.point2 && line.point2 === point.id) ||
                    (line.point1 === point.id && line.point2 === move.point2)
                );
                
                // ë‘˜ ì¤‘ í•˜ë‚˜ë§Œ ìˆë‹¤ë©´, ë‚˜ì¤‘ì— ì‚¼ê°í˜•ì„ ì™„ì„±í•  ê¸°íšŒ
                if ((hasLine1 && !hasLine2) || (!hasLine1 && hasLine2)) {
                    // ì™„ì„±ë  ì‚¼ê°í˜•ì´ ìœ íš¨í•œì§€ ë¯¸ë¦¬ í™•ì¸
                    const futureTriangle = [move.point1, move.point2, point.id].sort((a, b) => a - b);
                    if (!triangleHasInteriorElements(futureTriangle)) {
                        potentialTriangles++;
                    }
                }
            }
            
            if (potentialTriangles > 0) {
                nearMoves.push({
                    ...move,
                    potentialTriangles: potentialTriangles,
                    priority: 2
                });
            }
        }

        return nearMoves.sort((a, b) => b.potentialTriangles - a.potentialTriangles);
    }

    // ëª¨ë“  ìœ íš¨í•œ ìˆ˜ë¥¼ ì°¾ëŠ” í•¨ìˆ˜
    function getAllValidMoves() {
        const moves = [];

        for (let i = 0; i < points.length; i++) {
            for (let j = i + 1; j < points.length; j++) {
                const existingLine = lines.find(line =>
                    (line.point1 === i && line.point2 === j) ||
                    (line.point1 === j && line.point2 === i)
                );
                
                if (!existingLine) {
                    const point1 = { id: i, x: points[i].x, y: points[i].y };
                    const point2 = { id: j, x: points[j].x, y: points[j].y };
                    
                    if (!lineIntersectsExistingLines(point1, point2)) {
                        moves.push({ point1: i, point2: j });
                    }
                }
            }
        }

        return moves;
    }

    // ì‚¼ê°í˜•ì„ ì™„ì„±í•  ìˆ˜ ìˆëŠ” ìˆ˜ ì°¾ê¸° (ê°œì„ ëœ ë²„ì „)
    function findTriangleCompletingMoves(possibleMoves) {
        const triangleMoves = [];

        console.log("ğŸ” ì‚¼ê°í˜• ì™„ì„± ê¸°íšŒ ë¶„ì„ ì‹œì‘...");

        for (let move of possibleMoves) {
            // ì‹¤ì œë¡œ ìœ íš¨í•œ ì‚¼ê°í˜•ì´ ì™„ì„±ë˜ëŠ”ì§€ ì •í™•íˆ ì‹œë®¬ë ˆì´ì…˜
            const validTriangles = simulateValidTrianglesFormed(move.point1, move.point2);
            
            if (validTriangles.length > 0) {
                console.log(`ğŸ¯ ë°œê²¬! ${move.point1}-${move.point2} ì—°ê²°ì‹œ ${validTriangles.length}ê°œ ì‚¼ê°í˜• ì™„ì„± ê°€ëŠ¥`);
                validTriangles.forEach(triangle => {
                    console.log(`   ì‚¼ê°í˜•: ${triangle.join('-')}`);
                });
                
                triangleMoves.push({
                    ...move,
                    triangleCount: validTriangles.length,
                    priority: 1,
                    triangles: validTriangles
                });
            }
        }

        console.log(`ğŸ“Š ì´ ${triangleMoves.length}ê°œì˜ ì‚¼ê°í˜• ì™„ì„± ìˆ˜ ë°œê²¬`);
        return triangleMoves.sort((a, b) => b.triangleCount - a.triangleCount);
    }

    // ì‹¤ì œë¡œ ìœ íš¨í•œ ì‚¼ê°í˜• ì™„ì„± ì‹œë®¬ë ˆì´ì…˜ (ì—„ê²©í•œ ë£° ì ìš©)
    function simulateValidTrianglesFormed(point1Id, point2Id) {
        const validTriangles = [];
        
        console.log(`ğŸ§® ì‹œë®¬ë ˆì´ì…˜: ${point1Id}-${point2Id} ì—°ê²°ì‹œ...`);
        
        for (let point of points) {
            if (point.id === point1Id || point.id === point2Id) continue;
            
            // ì²« ë²ˆì§¸ ì„ : point1Id â†” point.id
            const hasLine1 = lines.some(line => 
                (line.point1 === point1Id && line.point2 === point.id) ||
                (line.point1 === point.id && line.point2 === point1Id)
            );
            
            // ë‘ ë²ˆì§¸ ì„ : point2Id â†” point.id  
            const hasLine2 = lines.some(line => 
                (line.point1 === point2Id && line.point2 === point.id) ||
                (line.point1 === point.id && line.point2 === point2Id)
            );

            if (hasLine1 && hasLine2) {
                const triangle = [point1Id, point2Id, point.id].sort((a, b) => a - b);
                
                console.log(`   ğŸ”º ì‚¼ê°í˜• í›„ë³´: ${triangle.join('-')}`);
                
                // ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì‚¼ê°í˜•ì¸ì§€ í™•ì¸
                const triangleExists = triangles.some(existingTriangle => {
                    const existingPoints = existingTriangle.points.slice().sort((a, b) => a - b);
                    return JSON.stringify(triangle) === JSON.stringify(existingPoints);
                });
                
                if (triangleExists) {
                    console.log(`      âŒ ì´ë¯¸ ì¡´ì¬í•¨`);
                    continue;
                }
                
                // ì‚¼ê°í˜• ë‚´ë¶€ì— ë‹¤ë¥¸ ìš”ì†Œê°€ ìˆëŠ”ì§€ í™•ì¸
                const hasInteriorElements = triangleHasInteriorElements(triangle);
                if (hasInteriorElements) {
                    console.log(`      âŒ ë‚´ë¶€ì— ë‹¤ë¥¸ ìš”ì†Œ ìˆìŒ`);
                    continue;
                }
                
                // ìƒˆë¡œ ê·¸ì„ ì„ ë¶„ì´ ì´ ì‚¼ê°í˜•ì„ ì§ì ‘ ì™„ì„±í•˜ëŠ”ì§€ í™•ì¸
                const isDirectTriangle = isTriangleDirectlyFormedByNewLine(triangle, point1Id, point2Id);
                if (!isDirectTriangle) {
                    console.log(`      âŒ ì§ì ‘ ì™„ì„±ì´ ì•„ë‹˜`);
                    continue;
                }
                
                console.log(`      âœ… ìœ íš¨í•œ ì‚¼ê°í˜•!`);
                validTriangles.push(triangle);
            }
        }
        
        console.log(`ğŸ§® ì‹œë®¬ë ˆì´ì…˜ ê²°ê³¼: ${validTriangles.length}ê°œ ìœ íš¨í•œ ì‚¼ê°í˜•`);
        return validTriangles;
    }

    // ì•„ë¬´ê²ƒë„ ì—°ê²°ë˜ì§€ ì•Šì€ ë‘ ì ë¼ë¦¬ ì—°ê²°í•˜ëŠ” ìˆ˜ ì°¾ê¸°
    function findIsolatedPointMoves(possibleMoves) {
        const isolatedMoves = [];

        for (let move of possibleMoves) {
            const point1Connections = getPointConnections(move.point1);
            const point2Connections = getPointConnections(move.point2);
            
            if (point1Connections.length === 0 && point2Connections.length === 0) {
                isolatedMoves.push({
                    ...move,
                    priority: 2
                });
            }
        }

        return isolatedMoves;
    }

    // í•œìª½ë§Œ ì—°ê²°ëœ ì ê³¼ ì•ˆ ì—°ê²°ëœ ì ì„ ì—°ê²°í•˜ëŠ” ìˆ˜ ì°¾ê¸°  
    function findExtensionMoves(possibleMoves) {
        const extensionMoves = [];

        for (let move of possibleMoves) {
            const point1Connections = getPointConnections(move.point1);
            const point2Connections = getPointConnections(move.point2);
            
            if ((point1Connections.length > 0 && point2Connections.length === 0) ||
                (point1Connections.length === 0 && point2Connections.length > 0)) {
                extensionMoves.push({
                    ...move,
                    priority: 3
                });
            }
        }

        return extensionMoves;
    }

    // ì ì˜ ì—°ê²° ìƒíƒœ í™•ì¸
    function getPointConnections(pointId) {
        return lines.filter(line =>
            line.point1 === pointId || line.point2 === pointId
        );
    }

    // í›„ë³´ ìˆ˜ë“¤ ì¤‘ì—ì„œ ìµœì ì˜ ìˆ˜ ì„ íƒ
    function selectBestFromMoves(moves, type) {
        if (moves.length === 0) return null;

        if (type === "triangle") {
            return moves[0]; // ì´ë¯¸ ì •ë ¬ë˜ì–´ ìˆìŒ
        }

        const scoredMoves = moves.map(move => ({
            ...move,
            strategicScore: calculateStrategicScore(move)
        }));

        scoredMoves.sort((a, b) => b.strategicScore - a.strategicScore);

        const topMoves = scoredMoves.slice(0, Math.min(3, scoredMoves.length));
        const selectedMove = topMoves[Math.floor(Math.random() * topMoves.length)];

        console.log(`ğŸ² ì „ëµì  ì ìˆ˜: ${selectedMove.strategicScore.toFixed(1)}`);
        return selectedMove;
    }

    // ì „ëµì  ì ìˆ˜ ê³„ì‚°
    function calculateStrategicScore(move) {
        let score = 0;

        const centerX = gameArea.offsetWidth / 2;
        const centerY = gameArea.offsetHeight / 2;

        const point1 = points[move.point1];
        const point2 = points[move.point2];

        const dist1 = Math.sqrt(Math.pow(point1.x - centerX, 2) + Math.pow(point1.y - centerY, 2));
        const dist2 = Math.sqrt(Math.pow(point2.x - centerY, 2) + Math.pow(point2.y - centerY, 2));

        score += (500 - dist1 * 0.5) + (500 - dist2 * 0.5);

        const connections1 = getPointConnections(move.point1).length;
        const connections2 = getPointConnections(move.point2).length;

        score += (connections1 + connections2) * 30;

        score += evaluateFutureTrianglePotential(move.point1, move.point2) * 20;

        return score;
    }

    // ë¯¸ë˜ ì‚¼ê°í˜• ê°€ëŠ¥ì„± í‰ê°€
    function evaluateFutureTrianglePotential(point1Id, point2Id) {
        let potential = 0;

        for (let i = 0; i < points.length; i++) {
            if (i === point1Id || i === point2Id) continue;
            
            const canConnect1 = canConnectPoints(point1Id, i);
            const canConnect2 = canConnectPoints(point2Id, i);
            
            if (canConnect1 && canConnect2) {
                potential += 1;
            }
        }

        return potential;
    }

    // ë‘ ì ì´ ì—°ê²° ê°€ëŠ¥í•œì§€ í™•ì¸
    function canConnectPoints(pointId1, pointId2) {
        const existingLine = lines.find(line =>
            (line.point1 === pointId1 && line.point2 === pointId2) ||
            (line.point1 === pointId2 && line.point2 === pointId1)
        );

        if (existingLine) return false;

        const point1 = { id: pointId1, x: points[pointId1].x, y: points[pointId1].y };
        const point2 = { id: pointId2, x: points[pointId2].x, y: points[pointId2].y };

        return !lineIntersectsExistingLines(point1, point2);
    }

    function lineIntersectsExistingLines(newPoint1, newPoint2) {
        // 1. ê¸°ì¡´ ì„ ë¶„ë“¤ê³¼ì˜ êµì°¨ ì²´í¬
        for (let existingLine of lines) {
            const existingP1 = points[existingLine.point1];
            const existingP2 = points[existingLine.point2];
            
            if (newPoint1.id === existingLine.point1 || newPoint1.id === existingLine.point2 ||
                newPoint2.id === existingLine.point1 || newPoint2.id === existingLine.point2) {
                continue;
            }
            
            if (doLinesIntersect(
                newPoint1.x, newPoint1.y, newPoint2.x, newPoint2.y,
                existingP1.x, existingP1.y, existingP2.x, existingP2.y
            )) {
                return true;
            }
        }
        
        // 2. ë‹¤ë¥¸ ì ë“¤ì„ ë„ˆë¬´ ê°€ê¹ê²Œ ì§€ë‚˜ê°€ëŠ”ì§€ ì²´í¬
        for (let point of points) {
            // ì„ ë¶„ì˜ ì–‘ ëì ì€ ì œì™¸
            if (point.id === newPoint1.id || point.id === newPoint2.id) {
                continue;
            }
            
            const distance = distanceFromPointToLine(
                point.x, point.y,
                newPoint1.x, newPoint1.y, newPoint2.x, newPoint2.y
            );
            
            // ì  ë°˜ì§€ë¦„(25px) ì •ë„ì˜ ì•ˆì „ ê±°ë¦¬ í™•ë³´
            if (distance < 25) {
                console.log(`âš ï¸ ì„ ë¶„ì´ ì  ${point.id}ë¥¼ ë„ˆë¬´ ê°€ê¹ê²Œ ì§€ë‚˜ê° (ê±°ë¦¬: ${distance.toFixed(1)}px)`);
                return true;
            }
        }
        
        return false;
    }

    // ì ê³¼ ì„ ë¶„ ì‚¬ì´ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
    function distanceFromPointToLine(px, py, x1, y1, x2, y2) {
        // ì„ ë¶„ì˜ ê¸¸ì´ì˜ ì œê³±
        const lineLength = Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2);
        
        if (lineLength === 0) {
            // ì„ ë¶„ì´ ì ì¸ ê²½ìš°
            return Math.sqrt(Math.pow(px - x1, 2) + Math.pow(py - y1, 2));
        }
        
        // ì ì—ì„œ ì„ ë¶„ìœ¼ë¡œì˜ ìˆ˜ì§ì„ ì˜ ìœ„ì¹˜ ê³„ì‚° (0~1 ì‚¬ì´)
        const t = Math.max(0, Math.min(1, ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / lineLength));
        
        // ì„ ë¶„ ìœ„ì˜ ê°€ì¥ ê°€ê¹Œìš´ ì 
        const closestX = x1 + t * (x2 - x1);
        const closestY = y1 + t * (y2 - y1);
        
        // ì ê³¼ ê°€ì¥ ê°€ê¹Œìš´ ì  ì‚¬ì´ì˜ ê±°ë¦¬
        return Math.sqrt(Math.pow(px - closestX, 2) + Math.pow(py - closestY, 2));
    }

    function doLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        
        if (Math.abs(denom) < 1e-10) {
            return false;
        }
        
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
        
        return t > 0 && t < 1 && u > 0 && u < 1;
    }

    function showWarningMessage(message) {
        const warning = document.createElement('div');
        warning.textContent = message;
        warning.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 100, 255, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 18px;
            z-index: 1000;
        `;
        document.body.appendChild(warning);
        setTimeout(() => warning.remove(), 2000);
    }

    function createTriangle(trianglePoints) {
        const p1 = points[trianglePoints[0]];
        const p2 = points[trianglePoints[1]];
        const p3 = points[trianglePoints[2]];

        const centerX = (p1.x + p2.x + p3.x) / 3;
        const centerY = (p1.y + p2.y + p3.y) / 3;

        const triangle = document.createElement('div');
        triangle.className = 'triangle';
        triangle.style.left = (centerX - 15) + 'px';
        triangle.style.top = (centerY - 15) + 'px';
        triangle.style.color = currentPlayer === 1 ? 'white' : 'pink';
        triangle.textContent = currentPlayer === 1 ? 'V' : 'O';

        gameArea.appendChild(triangle);
        triangles.push({ points: trianglePoints, player: currentPlayer, element: triangle });
    }

    function updateTurnDisplay() {
        const turnText = currentPlayer === 1 ? 'Your Turn' : 'Trinky is thinking...';
        document.getElementById('currentTurn').textContent = turnText;
        document.getElementById('currentTurn').style.color = currentPlayer === 1 ? 'white' : 'pink';
        
        if (isAiThinking) {
            document.getElementById('currentTurn').classList.add('ai-thinking');
        } else {
            document.getElementById('currentTurn').classList.remove('ai-thinking');
        }
        
        document.getElementById('turn1').style.display = currentPlayer === 1 ? 'inline' : 'none';
        document.getElementById('turn2').style.display = currentPlayer === 2 ? 'inline' : 'none';
    }

    function updateScoreboard() {
        document.getElementById('score1').textContent = scores.player1;
        document.getElementById('score2').textContent = scores.player2;
    }

    function isGameOver() {
        return getAllValidMoves().length === 0;
    }

    function showGameEndMessage() {
        isAiThinking = false;
        const winner = scores.player1 > scores.player2 ? "You Win! ğŸ‰" : 
                      scores.player2 > scores.player1 ? "Trinky Wins! ğŸ¤–" : "Draw! ğŸ¤";
        
        document.getElementById('currentTurn').textContent = `Game Over - ${winner}`;
        document.getElementById('currentTurn').style.background = 'rgba(0, 255, 0, 0.3)';
        
        setTimeout(() => {
            alert(`ê²Œì„ ì¢…ë£Œ!\n${winner}\n\nYour Score: ${scores.player1}\nTrinky Score: ${scores.player2}`);
        }, 500);
    }

    function restartGame() {
        points.forEach(point => point.element.remove());
        lines.forEach(line => line.element.remove());
        triangles.forEach(triangle => triangle.element.remove());
        
        points = [];
        lines = [];
        triangles = [];
        currentPlayer = 1;
        selectedPoint = null;
        scores = { player1: 0, player2: 0 };
        isAiThinking = false;
        
        updateScoreboard();
        updateTurnDisplay();
        setTimeout(createPoints, 100);
    }
  
    function goToIndex() {
        window.location.href = "index.html";
    }

    window.addEventListener('load', function() {
        setTimeout(createPoints, 100);
        updateTurnDisplay();
    });
</script>

</body>
</html>
